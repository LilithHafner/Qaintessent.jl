var documenterSearchIndex = {"docs":
[{"location":"circuit/#Circuit-Construction-and-Usage","page":"Circuit Construction and Usage","title":"Circuit Construction and Usage","text":"","category":"section"},{"location":"circuit/","page":"Circuit Construction and Usage","title":"Circuit Construction and Usage","text":"The output of typical Quantum simulation is the expectation values of the output quantum state based on certain measurement operators. In Qaintessent.jl, this is accomplished by applying a Quantum Circuit consisting of a  series of CircuitGate objects and Measurement Operators.","category":"page"},{"location":"circuit/","page":"Circuit Construction and Usage","title":"Circuit Construction and Usage","text":"CurrentModule = Qaintessent\nDocTestSetup = quote\n    using Qaintessent\nend","category":"page"},{"location":"circuit/#Moments","page":"Circuit Construction and Usage","title":"Moments","text":"","category":"section"},{"location":"circuit/","page":"Circuit Construction and Usage","title":"Circuit Construction and Usage","text":"When performing a quantum simulation, it may be required to define an intermediate state; this can be used to optimize the mapping of gates to physical qubits. In Qaintessent.jl, we allow for groupings of CircuitGate(s) that can be run in parallel into Moments. A Moment Example is shown below.","category":"page"},{"location":"circuit/","page":"Circuit Construction and Usage","title":"Circuit Construction and Usage","text":"Moment\napply(ψ::Vector{<:Complex}, m::Moment)","category":"page"},{"location":"circuit/#Qaintessent.Moment","page":"Circuit Construction and Usage","title":"Qaintessent.Moment","text":"Moment\n\nRepresents an intermediate state within a given circuit.\n\n\n\n\n\n","category":"type"},{"location":"circuit/#Qaintessent.apply-Tuple{Array{var\"#s7\",1} where var\"#s7\"<:Complex,Moment}","page":"Circuit Construction and Usage","title":"Qaintessent.apply","text":"apply(ψ::Vector{<:Complex}, m::Moment)\n\nreturns state vector of N qubits after applying a Moment{N} object to a quantum state vector of N qubits ψ\n\n\n\n\n\n","category":"method"},{"location":"circuit/#Moment-Example","page":"Circuit Construction and Usage","title":"Moment Example","text":"","category":"section"},{"location":"circuit/","page":"Circuit Construction and Usage","title":"Circuit Construction and Usage","text":"    using Qaintessent\n    N = 3\n    m = Moment(\n        [\n            circuit_gate(1, X, 2),\n            circuit_gate(3, RxGate(0.2π)),\n        ]\n    )\n    println(m) # hide","category":"page"},{"location":"circuit/","page":"Circuit Construction and Usage","title":"Circuit Construction and Usage","text":"The Moment can then be applied to a quantum state in state vector form.","category":"page"},{"location":"circuit/","page":"Circuit Construction and Usage","title":"Circuit Construction and Usage","text":"    ψ = randn(ComplexF64, 2^N)\n\n    apply(ψ, m)","category":"page"},{"location":"circuit/#Measurement-Operators","page":"Circuit Construction and Usage","title":"Measurement Operators","text":"","category":"section"},{"location":"circuit/","page":"Circuit Construction and Usage","title":"Circuit Construction and Usage","text":"Measurement operators can be defined in a MeasurementOperator object. These are used in conjunction with a series ofCircuitGate objects to create a Circuit object. Usage of MeasurementOperator can be seen in the Circuit Example shown below.","category":"page"},{"location":"circuit/","page":"Circuit Construction and Usage","title":"Circuit Construction and Usage","text":"MeasurementOperator","category":"page"},{"location":"circuit/#Qaintessent.MeasurementOperator","page":"Circuit Construction and Usage","title":"Qaintessent.MeasurementOperator","text":"MeasurementOperator{M,G}\n\nGeneral measurement operator. M is the number of wires affected by the measurement operator, G is the actual operator type (gate or sparse matrix).\n\njulia> m = MeasurementOperator(X, (1,))\nMeasurementOperator{1,XGate}(XGate(), (1,))\n\njulia> m = MeasurementOperator([0 1; 1 0], (1,))\nMeasurementOperator{1,SparseArrays.SparseMatrixCSC{Complex{Float64},Int64}}(\n  [2, 1]  =  1.0+0.0im\n  [1, 2]  =  1.0+0.0im, (1,))\n\n\n\n\n\n","category":"type"},{"location":"circuit/#Circuit","page":"Circuit Construction and Usage","title":"Circuit","text":"","category":"section"},{"location":"circuit/","page":"Circuit Construction and Usage","title":"Circuit Construction and Usage","text":"Circuit objects combine a Vector{Moment} object and Vector{MeasurementOperator} object. Applying a Circuit to a given input quantum state outputs the various expectation values from the measurement operators defined in the Qaintessent.MeasurementOperator objects. A simple circuit is shown in the Circuit Example.","category":"page"},{"location":"circuit/","page":"Circuit Construction and Usage","title":"Circuit Construction and Usage","text":"Circuit{N}\napply(ψ::Vector{<:Complex}, c::Circuit{N}) where {N}","category":"page"},{"location":"circuit/#Qaintessent.Circuit","page":"Circuit Construction and Usage","title":"Qaintessent.Circuit","text":"Circuit{N}\n\nQuantum circuit consisting of a unitary gate chain and measurement operators with N qubits.\n\n\n\n\n\n","category":"type"},{"location":"circuit/#Qaintessent.apply-Union{Tuple{N}, Tuple{Array{var\"#s7\",1} where var\"#s7\"<:Complex,Circuit{N}}} where N","page":"Circuit Construction and Usage","title":"Qaintessent.apply","text":"apply(ψ::Vector{<:Complex}, c::Circuit{N}) where {N}\n\nreturns list of expectation values from measurement operators in c.meas after applying circuit gates in c.cgc on state vector of N qubits ψ\n\n\n\n\n\n","category":"method"},{"location":"circuit/#Circuit-Example","page":"Circuit Construction and Usage","title":"Circuit Example","text":"","category":"section"},{"location":"circuit/","page":"Circuit Construction and Usage","title":"Circuit Construction and Usage","text":"julia> N = 3;\n\njulia> cgs = CircuitGate[circuit_gate(1, HadamardGate()), circuit_gate(2, HadamardGate()), circuit_gate(3, HadamardGate())];\n\njulia> meas = [MeasurementOperator(X, (1,))]; # Measure with regard to X basis on first qubit.\n\njulia> c = Circuit{N}(cgs, meas) # create circuit object\n\n    3 —[H ]—\n            \n    2 —[H ]—\n            \n    1 —[H ]—\n","category":"page"},{"location":"circuit/","page":"Circuit Construction and Usage","title":"Circuit Construction and Usage","text":"Applying the Circuit object to a 3-qubit quantum state all in the ground 0 state.","category":"page"},{"location":"circuit/","page":"Circuit Construction and Usage","title":"Circuit Construction and Usage","text":"julia> ψ = ComplexF64[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];\n\njulia> apply(ψ, c)\n1-element Array{Float64,1}:\n 0.9999999999999996","category":"page"},{"location":"gates/#Gates","page":"Gates","title":"Gates","text":"","category":"section"},{"location":"gates/","page":"Gates","title":"Gates","text":"Any quantum operation can be represented as a unitary matrix, which are referred to as gates. In Qaintessent.jl, basic gates are implemented using the abstract struct AbstractGate. The available basic quantum gates are seen below. Note that at this level of abstraction, wire index information is ignored and matrixes are permuted such that the fastest running qubit is also the fastest running index. ","category":"page"},{"location":"gates/","page":"Gates","title":"Gates","text":"These gates are permuted when creating the basic building blocks of Qaintessent.jl Quantum Circuit(s): CircuitGate(s).","category":"page"},{"location":"gates/","page":"Gates","title":"Gates","text":"CurrentModule = Qaintessent","category":"page"},{"location":"gates/","page":"Gates","title":"Gates","text":"AbstractGate","category":"page"},{"location":"gates/#Qaintessent.AbstractGate","page":"Gates","title":"Qaintessent.AbstractGate","text":"AbstractGate\n\nAbtract unitary quantum gate. N is the number of \"wires\" the gate acts on.\n\n\n\n\n\n","category":"type"},{"location":"gates/#AbstractGate-helper-functions","page":"Gates","title":"AbstractGate helper functions","text":"","category":"section"},{"location":"gates/","page":"Gates","title":"Gates","text":" matrix(::AbstractGate)\n sparse_matrix(::AbstractGate)","category":"page"},{"location":"gates/#Qaintessent.matrix-Tuple{AbstractGate}","page":"Gates","title":"Qaintessent.matrix","text":"matrix(::AbstractGate)\n\nreturns dense matrix representation of AbstractGate objects\n\nExamples\n\njulia> matrix(X)\n2×2 Array{Complex{Float64},2}:\n 0.0+0.0im  1.0+0.0im\n 1.0+0.0im  0.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"gates/#Qaintessent.sparse_matrix-Tuple{AbstractGate}","page":"Gates","title":"Qaintessent.sparse_matrix","text":"sparse_matrix(::AbstractGate)\n\nreturns sparse matrix representation of AbstractGate objects\n\nExamples\n\njulia> sparse_matrix(X)\n2×2 SparseArrays.SparseMatrixCSC{Complex{Float64},Int64} with 2 stored entries:\n  [2, 1]  =  1.0+0.0im\n  [1, 2]  =  1.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"gates/","page":"Gates","title":"Gates","text":"Base.adjoint(::AbstractGate)\nnum_wires(::AbstractGate)\nBase.isapprox(g1::G, g2::G) where {G <: AbstractGate}","category":"page"},{"location":"gates/#Base.adjoint-Tuple{AbstractGate}","page":"Gates","title":"Base.adjoint","text":"Base.adjoint(::AbstractGate)\n\nreturns adjoint of AbstractGate objects\n\nExamples\n\njulia> X ≈ X\ntrue\n\njulia> Y ≈ Z\nfalse\n\njulia> RxGate(0.3) ≈ RxGate(0.3)\ntrue\n\njulia> RxGate(0.3) ≈ RxGate(0.2)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"gates/#Qaintessent.num_wires-Tuple{AbstractGate}","page":"Gates","title":"Qaintessent.num_wires","text":"num_wires(::AbstractGate)\n\nreturns number of wires affected by AbstractGate object.\n\nExamples\n\njulia> num_wires(X)\n1\n\njulia> num_wires(SwapGate())\n2\n\n\n\n\n\n","category":"method"},{"location":"gates/#Base.isapprox-Union{Tuple{G}, Tuple{G,G}} where G<:AbstractGate","page":"Gates","title":"Base.isapprox","text":"Base.isapprox(g1::G, g2::G) where {G <: AbstractGate}\n\nreturns true if input AbstractGates are of same type with same paremeters\n\nExamples\n\njulia> X ≈ X\ntrue\n\njulia> X ≈ Y\nfalse\n\njulia> RxGate(0.1) ≈ RxGate(0.2)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"gates/","page":"Gates","title":"Gates","text":"kron(m::Union{UniformScaling{Bool},G}...) where {G<:AbstractGate}","category":"page"},{"location":"gates/#Base.kron-Union{Tuple{Vararg{Union{LinearAlgebra.UniformScaling{Bool}, G},N} where N}, Tuple{G}} where G<:AbstractGate","page":"Gates","title":"Base.kron","text":"kron(m::Union{UniformScaling{Bool},G}...) where {G<:AbstractGate}\n\nreturns sparse matrix representation of kronecker product of AbstractGate objects\n\n\n\n\n\n","category":"method"},{"location":"gates/#Basic-Single-Qubit-Gates","page":"Gates","title":"Basic Single Qubit Gates","text":"","category":"section"},{"location":"gates/","page":"Gates","title":"Gates","text":"XGate\nYGate\nZGate\nHadamardGate\nSGate\nSdagGate\nTGate\nTdagGate","category":"page"},{"location":"gates/#Qaintessent.XGate","page":"Gates","title":"Qaintessent.XGate","text":"Pauli X gate\n\nX = beginpmatrix 0  1  1  0 endpmatrix\n\n\n\n\n\n","category":"type"},{"location":"gates/#Qaintessent.YGate","page":"Gates","title":"Qaintessent.YGate","text":"Pauli Y gate\n\nY = beginpmatrix 0  -i  i  0 endpmatrix\n\n\n\n\n\n","category":"type"},{"location":"gates/#Qaintessent.ZGate","page":"Gates","title":"Qaintessent.ZGate","text":"Pauli Z gate\n\nZ = beginpmatrix 1  0  0  -1 endpmatrix\n\n\n\n\n\n","category":"type"},{"location":"gates/#Qaintessent.HadamardGate","page":"Gates","title":"Qaintessent.HadamardGate","text":"Hadamard gate\n\nH = frac1sqrt2 beginpmatrix 1  1  1  1 endpmatrix\n\n\n\n\n\n","category":"type"},{"location":"gates/#Qaintessent.SGate","page":"Gates","title":"Qaintessent.SGate","text":"S gate\n\nS = beginpmatrix 1  0  0  i endpmatrix\n\n\n\n\n\n","category":"type"},{"location":"gates/#Qaintessent.SdagGate","page":"Gates","title":"Qaintessent.SdagGate","text":"S^{†} gate\n\nS^ = beginpmatrix 1  0  0  -i endpmatrix\n\n\n\n\n\n","category":"type"},{"location":"gates/#Qaintessent.TGate","page":"Gates","title":"Qaintessent.TGate","text":"T gate\n\nT = beginpmatrix 1  0  0  e^fraciπ4 endpmatrix\n\n\n\n\n\n","category":"type"},{"location":"gates/#Qaintessent.TdagGate","page":"Gates","title":"Qaintessent.TdagGate","text":"T^{†} gate\n\nT^ = beginpmatrix 1  0  0  e^-fraciπ4 endpmatrix\n\n\n\n\n\n","category":"type"},{"location":"gates/#Basic-Two-Qubit-Gates","page":"Gates","title":"Basic Two Qubit Gates","text":"","category":"section"},{"location":"gates/","page":"Gates","title":"Gates","text":"SwapGate\n","category":"page"},{"location":"gates/#Qaintessent.SwapGate","page":"Gates","title":"Qaintessent.SwapGate","text":"Swap gate\n\nSWAP = beginpmatrix 1  0  0  0  0  0  1  0  0  1  0  0  0  0  0  1 endpmatrix\n\n\n\n\n\n","category":"type"},{"location":"gates/#Parametrized-Gates","page":"Gates","title":"Parametrized Gates","text":"","category":"section"},{"location":"gates/","page":"Gates","title":"Gates","text":"RxGate\nRyGate\nRzGate\nRotationGate\nPhaseShiftGate\nEntanglementXXGate\nEntanglementYYGate\nEntanglementZZGate","category":"page"},{"location":"gates/#Qaintessent.RxGate","page":"Gates","title":"Qaintessent.RxGate","text":"Rotation-X gate\n\nR_x(theta) = beginpmatrix cos(fractheta2)  -isin(fractheta2)  -isin(fractheta2)  cos(fractheta2) endpmatrix\n\n\n\n\n\n","category":"type"},{"location":"gates/#Qaintessent.RyGate","page":"Gates","title":"Qaintessent.RyGate","text":"Rotation-Y gate\n\nR_y(theta) = beginpmatrix cos(fractheta2)  -sin(fractheta2)  sin(fractheta2)  cos(fractheta2) endpmatrix\n\n\n\n\n\n","category":"type"},{"location":"gates/#Qaintessent.RzGate","page":"Gates","title":"Qaintessent.RzGate","text":"Rotation-Z gate\n\nR_z(theta) = beginpmatrix e^frac-itheta2  0  0  e^fracitheta2 endpmatrix\n\n\n\n\n\n","category":"type"},{"location":"gates/#Qaintessent.RotationGate","page":"Gates","title":"Qaintessent.RotationGate","text":"General rotation operator gate: rotation by angle `θ` around unit vector `n`.\n\nR_vec v(theta) = cos(fractheta2)I - isin(fractheta2)vec v sigma  sigma = X Y Z\n\n\n\n\n\n","category":"type"},{"location":"gates/#Qaintessent.PhaseShiftGate","page":"Gates","title":"Qaintessent.PhaseShiftGate","text":"Phase shift gate\n\nP(phi) = beginpmatrix 1  0  0  e^iphi endpmatrix\n\n\n\n\n\n","category":"type"},{"location":"gates/#Qaintessent.EntanglementXXGate","page":"Gates","title":"Qaintessent.EntanglementXXGate","text":"Entanglement-XX gate\n\nG_x(theta) = e^-i theta X otimes X  2\n\nReference:\n\nB. Kraus and J. I. Cirac\n\nOptimal creation of entanglement using a two-qubit gate\n\nPhys. Rev. A 63, 062309 (2001)\n\n\n\n\n\n","category":"type"},{"location":"gates/#Qaintessent.EntanglementYYGate","page":"Gates","title":"Qaintessent.EntanglementYYGate","text":"Entanglement-YY gate\n\nG_y(theta) = e^-i theta Y otimes Y  2\n\nReference:\n\nB. Kraus and J. I. Cirac\n\nOptimal creation of entanglement using a two-qubit gate\n\nPhys. Rev. A 63, 062309 (2001)\n\n\n\n\n\n","category":"type"},{"location":"gates/#Qaintessent.EntanglementZZGate","page":"Gates","title":"Qaintessent.EntanglementZZGate","text":"Entanglement-ZZ gate\n\nG_z(theta) = e^-i theta Z otimes Z  2\n\nReference:\n\nB. Kraus and J. I. Cirac\n\nOptimal creation of entanglement using a two-qubit gate\n\nPhys. Rev. A 63, 062309 (2001)\n\n\n\n\n\n","category":"type"},{"location":"gates/#Controlled-Gates","page":"Gates","title":"Controlled Gates","text":"","category":"section"},{"location":"gates/","page":"Gates","title":"Gates","text":"Arbitrary controlled gates using the basic gates defined above are available.","category":"page"},{"location":"gates/","page":"Gates","title":"Gates","text":"ControlledGate","category":"page"},{"location":"gates/#Qaintessent.ControlledGate","page":"Gates","title":"Qaintessent.ControlledGate","text":"ControlledGate{G}(U::G, M::Int) where {G<:AbstractGate}\n\nreturns ControlledGate object. Controls AbstractGate of type G with M control wires\n\n\n\n\n\n","category":"type"},{"location":"gates/#ControlledGate-helper-functions","page":"Gates","title":"ControlledGate helper functions","text":"","category":"section"},{"location":"gates/","page":"Gates","title":"Gates","text":"control_wires\ntarget_wires","category":"page"},{"location":"gates/#Qaintessent.control_wires","page":"Gates","title":"Qaintessent.control_wires","text":"control_wires(g::ControlledGate)\n\nreturn control wires for a ControlledGate\n\nExamples\n\n# controlled gate with 2 control wires\njulia> ccnot = ControlledGate(X, 2);\njulia> target_wires(ccnot)\n2\n\n\n\n\n\n","category":"function"},{"location":"gates/#Qaintessent.target_wires","page":"Gates","title":"Qaintessent.target_wires","text":"target_wires(g::ControlledGate)\n\nreturn target wires for a ControlledGate\n\nExamples\n\n# controlled gate with 1 target wire\njulia> cnot = ControlledGate(X, 1);\njulia> target_wires(cnot)\n1\n\n\n\n\n\n","category":"function"},{"location":"circuitgates/#Circuit-Gates","page":"Circuit Gates","title":"Circuit Gates","text":"","category":"section"},{"location":"circuitgates/","page":"Circuit Gates","title":"Circuit Gates","text":"A CircuitGate object consists of an Qaintessent.AbstractGate and wire ordering information. This allows an arbitrary quantum operation can be encoded as vector of CircuitGate objects and applied to a given quantum state.","category":"page"},{"location":"circuitgates/","page":"Circuit Gates","title":"Circuit Gates","text":"CurrentModule = Qaintessent\nDocTestSetup = quote\n    using Qaintessent\nend","category":"page"},{"location":"circuitgates/#CircuitGate","page":"Circuit Gates","title":"CircuitGate","text":"","category":"section"},{"location":"circuitgates/","page":"Circuit Gates","title":"Circuit Gates","text":"CircuitGate\ncircuit_gate\napply(ψ::Vector{<:Complex}, cg::CircuitGate{M,G}) where {M,G}\napply(ψ::Vector{<:Complex}, cgs::Vector{<:CircuitGate})\nsparse_matrix(cg::CircuitGate{M,G}, N::Integer=0) where {M,G <: AbstractGate}\nsparse_matrix(cgs::Vector{<:CircuitGate}, N::Integer=0)","category":"page"},{"location":"circuitgates/#Qaintessent.CircuitGate","page":"Circuit Gates","title":"Qaintessent.CircuitGate","text":"CircuitGate{M,G} <: AbstractCircuitGate\n\nUnitary quantum circuit gate. M is the number of wires affected by the CircuitGate, and G is the basic gate used to construct the CircuitGate.\n\n\n\n\n\n","category":"type"},{"location":"circuitgates/#Qaintessent.circuit_gate","page":"Circuit Gates","title":"Qaintessent.circuit_gate","text":"circuit_gate\n\nhelper function to construct a CircuitGate object from basic gate types.\n\njulia> circuit_gate(1, X)\nCircuitGate{1,XGate}((1,), XGate())\n\njulia> circuit_gate(1, X, 2)\nCircuitGate{2,ControlledGate{XGate}}((1, 2), ControlledGate{XGate}(XGate(), 1))\n\njulia> circuit_gate((1,2), SwapGate(), (3,4))\nCircuitGate{4,ControlledGate{SwapGate}}((1, 2, 3, 4), ControlledGate{SwapGate}(SwapGate(), 2))\n\n\n\n\n\n","category":"function"},{"location":"circuitgates/#Qaintessent.apply-Union{Tuple{G}, Tuple{M}, Tuple{Array{var\"#s7\",1} where var\"#s7\"<:Complex,CircuitGate{M,G}}} where G where M","page":"Circuit Gates","title":"Qaintessent.apply","text":"apply(ψ::Vector{<:Complex}, cg::CircuitGate{M,G}) where {M,G}\n\nApply a CircuitGate to a quantum state vector ψ.\n\nExamples\n\njulia> cg = circuit_gate(1, HadamardGate());\njulia> ψ = [1 0];\njulia> apply(ψ, cg)\n2-element Array{Complex{Float64},1}:\n 0.7071067811865475 + 0.0im\n 0.7071067811865475 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"circuitgates/#Qaintessent.apply-Tuple{Array{var\"#s7\",1} where var\"#s7\"<:Complex,Array{var\"#s6\",1} where var\"#s6\"<:CircuitGate}","page":"Circuit Gates","title":"Qaintessent.apply","text":"apply(ψ::Vector{<:Complex}, cgs::Vector{<:CircuitGate})\n\nApply a sequence of CircuitGate(s) to a quantum state vector ψ.\n\nExamples\n\njulia> cgs = [circuit_gate(1, HadamardGate()),\n                circuit_gate(1, X),\n                circuit_gate(1, Y)];\njulia> ψ = [1 0];\njulia> apply(ψ, cgs)\n2-element Array{Complex{Float64},1}:\n 0.0 - 0.7071067811865475im\n 0.0 + 0.7071067811865475im\n\n\n\n\n\n","category":"method"},{"location":"circuitgates/#Qaintessent.sparse_matrix-Union{Tuple{CircuitGate{M,G}}, Tuple{G}, Tuple{M}, Tuple{CircuitGate{M,G},Integer}} where G<:AbstractGate where M","page":"Circuit Gates","title":"Qaintessent.sparse_matrix","text":"sparse_matrix(cg::CircuitGate{M,G}, N::Integer=0) where {M,G <: AbstractGate}\n\nreturns matrix representation of a CircuitGate object that can applied to a state vector of N qubits. N can be\n\nExamples\n\njulia> cg = circuit_gate(2, Y, 1);\njulia> sparse_matrix(cg)\n4×4 SparseArrays.SparseMatrixCSC{Complex{Float64},Int64} with 4 stored entries:\n  [1, 1]  =  1.0+0.0im\n  [4, 2]  =  0.0+1.0im\n  [3, 3]  =  1.0+0.0im\n  [2, 4]  =  0.0-1.0im\n\n\n\n\n\n","category":"method"},{"location":"circuitgates/#Qaintessent.sparse_matrix","page":"Circuit Gates","title":"Qaintessent.sparse_matrix","text":"sparse_matrix(cgs::Vector{<:CircuitGate}, N::Integer=0)\n\nreturns matrix representation of a Vector{<:CircuitGate} object that can applied to a state vector of N qubits.\n\nExamples\n\njulia> cgs = CircuitGate[\n                circuit_gate(2, Y, 1),\n                circuit_gate(2, Z),\n                circuit_gate(1, HadamardGate())\n                ];\njulia> sparse_matrix(cgs)\n4×4 SparseArrays.SparseMatrixCSC{Complex{Float64},Int64} with 8 stored entries:\n  [1, 1]  =  0.707107+0.0im\n  [2, 1]  =  0.707107+0.0im\n  [3, 2]  =  0.0-0.707107im\n  [4, 2]  =  0.0+0.707107im\n  [3, 3]  =  -0.707107+0.0im\n  [4, 3]  =  -0.707107+0.0im\n  [1, 4]  =  0.0-0.707107im\n  [2, 4]  =  0.0+0.707107im\n\n\n\n\n\n","category":"function"},{"location":"circuitgates/#Compilation-of-abitrary-unity-operation","page":"Circuit Gates","title":"Compilation of abitrary unity operation","text":"","category":"section"},{"location":"circuitgates/","page":"Circuit Gates","title":"Circuit Gates","text":"An arbitrary unitary operation can be compiled into a vector of CircuitGate objects","category":"page"},{"location":"circuitgates/","page":"Circuit Gates","title":"Circuit Gates","text":"unitary2circuit","category":"page"},{"location":"circuitgates/#Qaintessent.unitary2circuit","page":"Circuit Gates","title":"Qaintessent.unitary2circuit","text":"unitary2circuit(m::Matrix{Complex64,2}) where {N}\n\ncompiles quantum circuit from given unitary matrix. Implements algorithms from ff10.1016/j.cpc.2019.107001f, 10.1103/PhysRevA.69.032315, arxiv.org:1003.5760, arxiv:quant-ph/0404089\n\nExamples\n\nM = Stewart(ComplexF64, 4);\ncgc = unitary2circuit(M)\n\n\n\n\n\n","category":"function"},{"location":"view/#Display-Documentation","page":"Display Documentation","title":"Display Documentation","text":"","category":"section"},{"location":"view/","page":"Display Documentation","title":"Display Documentation","text":"CurrentModule = Qaintessent","category":"page"},{"location":"view/#Show","page":"Display Documentation","title":"Show","text":"","category":"section"},{"location":"view/","page":"Display Documentation","title":"Display Documentation","text":"Base.show(io::IO, c::Circuit{N}) where {N}","category":"page"},{"location":"view/#Base.show-Union{Tuple{N}, Tuple{IO,Circuit{N}}} where N","page":"Display Documentation","title":"Base.show","text":"Base.show(io::IO, c::Circuit) = Base.show(io, c.cgc)\n\nextends base show method to draw visual representation of a Circuit{N} object.\n\n\n\n\n\n","category":"method"},{"location":"qasm/#OpenQASM","page":"OpenQASM","title":"OpenQASM","text":"","category":"section"},{"location":"qasm/","page":"OpenQASM","title":"OpenQASM","text":"Qaintessent.jl provides some basic OpenQASM 2.0 support. This allows the importing of most QASM files as Circuit objects. Currently, only basic exports of Circuits is supported: custom measurements and multi-control CircuitGates cannot be exported. An example of OpenQASM usage is seen in the example below.","category":"page"},{"location":"qasm/","page":"OpenQASM","title":"OpenQASM","text":"CurrentModule = Qaintessent","category":"page"},{"location":"qasm/","page":"OpenQASM","title":"OpenQASM","text":"    qasm2cgc(txt::String)","category":"page"},{"location":"qasm/#Qaintessent.qasm2cgc-Tuple{String}","page":"OpenQASM","title":"Qaintessent.qasm2cgc","text":"qasm2cgc(txt::String)\n\nconverts OpenQASM 2.0 text to Circuit{N} object\n\n\n\n\n\n","category":"method"},{"location":"qasm/","page":"OpenQASM","title":"OpenQASM","text":"    cgc2qasm(c::Circuit{N}) where {N}","category":"page"},{"location":"qasm/#Qaintessent.cgc2qasm-Union{Tuple{Circuit{N}}, Tuple{N}} where N","page":"OpenQASM","title":"Qaintessent.cgc2qasm","text":"cgc2qasm(c::Circuit{N}) where {N}\n\nconverts Circuit{N} object to OpenQASM 2.0 representation\n\n\n\n\n\n","category":"method"},{"location":"qasm/#Example","page":"OpenQASM","title":"Example","text":"","category":"section"},{"location":"qasm/","page":"OpenQASM","title":"OpenQASM","text":"using Qaintessent\nusing LinearAlgebra\n\nN = 3\ncgs_ref = CircuitGate[\n    circuit_gate(3, XGate()),\n    circuit_gate(1, RyGate(0.3π)),\n    circuit_gate(2, RzGate(2.4)),\n    circuit_gate(2, TGate()),\n    circuit_gate(1, XGate(), 2),\n    circuit_gate(3, RzGate(0.3), 1)\n    ]\n\nmeas = MeasurementOperator(Matrix{Float64}(I, 2^N, 2^N), (1,2,3))\nc_ref = Circuit{N}(cgs_ref, [meas])\nqasm_rep = cgc2qasm(c_ref)\n\ncgc_from_qasm = qasm2cgc(qasm_rep)\n\ncgc_from_qasm\n# output\n    \n    3 —[X ]——————————————[Rz]—\n                          |\n    2 —[Rz]——[T ]———•—————————\n                    |     |\n    1 —[Ry]————————[X ]———•———","category":"page"},{"location":"densitymatrices/#Density-Matrix-representation","page":"Density Matrix representation","title":"Density Matrix representation","text":"","category":"section"},{"location":"densitymatrices/","page":"Density Matrix representation","title":"Density Matrix representation","text":"Qaintessent.jl supports the manipulation of mixed states as Density Matrices(s).","category":"page"},{"location":"densitymatrices/","page":"Density Matrix representation","title":"Density Matrix representation","text":"CurrentModule = Qaintessent","category":"page"},{"location":"densitymatrices/#Density-Matrices","page":"Density Matrix representation","title":"Density Matrices","text":"","category":"section"},{"location":"densitymatrices/","page":"Density Matrix representation","title":"Density Matrix representation","text":"Density matrices are stored as linear combination of Pauli matrices. Given a quantum state of N qubits, we require a Vector{<:Real} of length 4^N to  store the mixed state.","category":"page"},{"location":"densitymatrices/","page":"Density Matrix representation","title":"Density Matrix representation","text":"DensityMatrix(v::AbstractVector{<:Real}, N::Integer)\nDensityMatrix(v::AbstractVector{<:Real})","category":"page"},{"location":"densitymatrices/#Qaintessent.DensityMatrix-Tuple{AbstractArray{var\"#s7\",1} where var\"#s7\"<:Real,Integer}","page":"Density Matrix representation","title":"Qaintessent.DensityMatrix","text":"DensityMatrix(v::AbstractVector{<:Real}, N::Integer)\n\nDensity matrix representation given Pauli-vector dotted with with vector of coefficients\n\n\n\n\n\n","category":"method"},{"location":"densitymatrices/#Qaintessent.DensityMatrix-Tuple{AbstractArray{var\"#s7\",1} where var\"#s7\"<:Real}","page":"Density Matrix representation","title":"Qaintessent.DensityMatrix","text":"DensityMatrix(v::AbstractVector{<:Real})\n\nDensity matrix representation given Pauli-vector dotted with with vector of coefficients\n\n\n\n\n\n","category":"method"},{"location":"densitymatrices/","page":"Density Matrix representation","title":"Density Matrix representation","text":"Several helper functions are added to crate DensityMatrix objects from quantum states in statevector form.","category":"page"},{"location":"densitymatrices/","page":"Density Matrix representation","title":"Density Matrix representation","text":"density_from_statevector(ψ::Vector)\ndensity_from_matrix(ρmat::AbstractMatrix)","category":"page"},{"location":"densitymatrices/#Qaintessent.density_from_statevector-Tuple{Array{T,1} where T}","page":"Density Matrix representation","title":"Qaintessent.density_from_statevector","text":"density_from_statevector(ψ::Vector)\n\nConstruct density matrix |ψ⟩⟨ψ| (Pauli representation) corresponding to quantum state ψ.\n\njulia> ψ = 1/sqrt(2)[1, -1]; # create ket - state.\njulia> ρ = density_from_statevector(ψ)\nDensityMatrix([0.9999999999999998, -0.9999999999999998, 0.0, 0.0], 1)\n\n\n\n\n\n","category":"method"},{"location":"densitymatrices/#Qaintessent.density_from_matrix-Tuple{AbstractArray{T,2} where T}","page":"Density Matrix representation","title":"Qaintessent.density_from_matrix","text":"density_from_matrix(ρmat::AbstractMatrix)\n\nConstruct density matrix in Pauli representation from matrix ρmat.\n\njulia> ρmat = 0.15 .*[ 1 -1; -1  1] + 0.35 .* [1 1; 1 1]; # create mixed state of + and -.\njulia> ρ = density_from_matrix(ρmat)\nDensityMatrix([1.0, 0.39999999999999997, 0.0, 0.0], 1)\n\n\n\n\n\n","category":"method"},{"location":"densitymatrices/","page":"Density Matrix representation","title":"Density Matrix representation","text":"Once created, they can be treated similar to a statevector, see Circuit Construction and Usage.","category":"page"},{"location":"densitymatrices/","page":"Density Matrix representation","title":"Density Matrix representation","text":"apply(ρ::DensityMatrix, cgs::Vector{<:CircuitGate})\napply(ρ::DensityMatrix, c::Circuit{N}) where {N}","category":"page"},{"location":"densitymatrices/#Qaintessent.apply-Tuple{DensityMatrix,Array{var\"#s7\",1} where var\"#s7\"<:CircuitGate}","page":"Density Matrix representation","title":"Qaintessent.apply","text":"apply(ρ::DensityMatrix, cgs::Vector{<:CircuitGate})\n\nApply a CircuitGate to a quantum density matrix ρ.\n\n\n\n\n\n","category":"method"},{"location":"densitymatrices/#Qaintessent.apply-Union{Tuple{N}, Tuple{DensityMatrix,Circuit{N}}} where N","page":"Density Matrix representation","title":"Qaintessent.apply","text":"apply(ρ::DensityMatrix, c::Circuit{N}) where {N}\n\nCompute list of expectation values from measurement operators in c.meas, after applying circuit gates in c.cgc on the N-qubit density matrix ρ\n\n\n\n\n\n","category":"method"},{"location":"gradients/#Gradients","page":"Gradients","title":"Gradients","text":"","category":"section"},{"location":"gradients/","page":"Gradients","title":"Gradients","text":"Qaintessent.jl can perform a backward pass through a circuit to compute gradients of a (fictitious) cost function with respect to the circuit parameters and input wavefunction. Since quantum gates are unitary, the intermediate quantum states can be re-computed on the fly during backwards traversal, i.e., need not be stored during the forward pass.","category":"page"},{"location":"gradients/","page":"Gradients","title":"Gradients","text":"See also this article regarding complex differentiation.","category":"page"},{"location":"gradients/","page":"Gradients","title":"Gradients","text":"CurrentModule = Qaintessent","category":"page"},{"location":"gradients/","page":"Gradients","title":"Gradients","text":"Qaintessent.gradients","category":"page"},{"location":"gradients/#Qaintessent.gradients","page":"Gradients","title":"Qaintessent.gradients","text":"gradients(c::Circuit{N}, ψ::AbstractVector, Δ::AbstractVector{<:Real}) where {N}\n\nPerform a backward pass to compute gradients of a (fictitious) cost function with respect to the circuit parameters of c and input wavefunction ψ. Δ contains the cost function gradients with respect to the circuit outputs (measurement operator averages). The gradients with respect to the circuit parameters are returned in a duplicate circuit; the overall return value is the tuple (dc::Circuit{N}, dψ::AbstractVector).\n\n\n\n\n\ngradients(c::Circuit{N}, ρ::DensityMatrix, Δ::AbstractVector{<:Real}) where {N}\n\nPerform a backward pass to compute gradients of a (fictitious) cost function with respect to the circuit parameters of c and input density matrix ρ. Δ contains the cost function gradients with respect to the circuit outputs (measurement operator averages). The gradients with respect to the circuit parameters are returned in a duplicate circuit; the overall return value is the tuple (dc::Circuit{N}, dρ::DensityMatrix).\n\n\n\n\n\n","category":"function"},{"location":"#Qaintessent.jl-Documentation","page":"Home","title":"Qaintessent.jl Documentation","text":"","category":"section"},{"location":"#Table-of-Contents","page":"Home","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\", \"circuit.md\", \"gates.md\", \"densitymatrices.md\", \"gradients.md\", \"qasm.md\", \"view.md\"]","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Qaintessent","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
